import os
import platform
import tempfile
import time
from typing import NamedTuple, Optional
import xml.dom.minidom
from xml.etree.ElementTree import Element
from xml.etree.ElementTree import SubElement
from xml.etree.ElementTree import tostring
import xml.etree.ElementTree as ET

try:
    import mujoco_viewer
    import ring

    del mujoco_viewer, ring
except ImportError:
    raise Exception(
        "The `view` function requires `imt-ring` and `mujoco-python-viewer` "
        "package. Install with `pip install imt-ring mujoco-python-viewer"
    )

import jax
import mediapy
import mujoco
import mujoco_viewer
import numpy as np
import qmt
import ring
from ring.rendering.mujoco_render import MujocoScene

import imt


def _mujoco_model_to_string_windows(model):
    temp_filename = "temp_mujoco_model.xml"
    try:
        # Save the model to a temporary file
        mujoco.mj_saveLastXML(temp_filename, model)
        # Read the XML content back into a string
        with open(temp_filename, "r") as file:
            xml_string = file.read()
    finally:
        # Ensure the temporary file is deleted
        if os.path.exists(temp_filename):
            os.remove(temp_filename)

    return xml_string


def _mujoco_model_to_string(model):

    if platform.system() == "Windows":
        return _mujoco_model_to_string_windows(model)

    # Use a temporary file to save the XML
    with tempfile.NamedTemporaryFile(suffix=".xml", delete=True) as temp_file:
        mujoco.mj_saveLastXML(temp_file.name, model)
        # Read the XML content back into a string
        with open(temp_file.name, "r") as file:
            xml_string = file.read()

    return xml_string


def _add_capsule_geoms_to_xml(
    xml_string: str,
    fromto_dict: dict[str, list[np.ndarray]],
    radius: float,
    color: np.ndarray,
) -> str:
    """
    Modify the XML string to add capsule geoms to specified bodies.

    Args:
        xml_string (str): The XML string of a MuJoCo model.
        fromto_dict (dict): A dictionary mapping body names to lists of (6,) np arrays
        radius (float): Radial size of added capsules
        color (np.ndarray): Rgba color of capsules

    Returns:
        str: The modified XML string.
    """
    # Parse the XML string
    root = ET.fromstring(xml_string)

    # Iterate over the fromto_dict dictionary
    for body_name, fromto_list in fromto_dict.items():
        # Find the corresponding body element
        body = root.find(f".//body[@name='{body_name}']")
        if body is None:
            raise ValueError(f"Body with name '{body_name}' not found in the XML.")

        # Add a geom for each fromto array
        for i, fromto in enumerate(fromto_list):
            if fromto.shape != (6,):
                raise ValueError(
                    f"Invalid shape for fromto array {i} in body "
                    f"'{body_name}': {fromto.shape}. Expected (6,)."
                )

            # Create a new geom element
            geom = ET.SubElement(body, "geom")
            geom.set("type", "capsule")
            geom.set("fromto", " ".join(map(str, fromto)))
            geom.set("size", f"{radius}")
            geom.set("rgba", " ".join(map(str, color)))

    # Convert the modified XML tree back to a string
    return ET.tostring(root, encoding="unicode")


class VisOptions(NamedTuple):
    show_body_xyz: bool = True
    body_xyz_dim: float = 0.05

    show_stars: bool = True
    show_floor: bool = False
    floor_material: str = "grey"

    show_joint_to_joint: bool = True
    joint_to_joint_color: list[float] = [0.5, 0.5, 0.5, 1]
    show_joint_to_imu: bool = True
    joint_to_imu_color: list[float] = [0.15, 0.56, 0.96, 0.8]

    show_imu: bool = True
    imu_type: str = "box"
    imu_dim: str = "0.05 0.03 0.02"
    imu_color: str = "dustin_exp_orange"
    imu_offset: list[float] = [0.0, 0, 0]

    show_imu_xyz: bool = True
    imu_xyz_dim: float = 0.04


def create_xml_from_graph(
    graph, positions, vis_options: VisOptions, skip_0th_body_imu: bool = True
):
    root = Element("x_xy", model="autogenerated")

    # Add options
    _ = SubElement(root, "options", gravity="0 0 9.81", dt="0.01")

    # Create the worldbody
    worldbody = SubElement(root, "worldbody")

    # Dictionary to keep track of bodies for hierarchy
    body_elements = {}

    for idx, parent_idx in enumerate(graph):
        # Define the body name
        body_name = str(idx) if parent_idx != -1 else "0"

        if parent_idx == -1:
            # Create the root body (connected to Earth)
            body_pos = " ".join(map(str, positions[idx][0]))
            body = SubElement(
                worldbody, "body", name=body_name, joint="free", pos=body_pos
            )
            if vis_options.show_body_xyz:
                SubElement(body, "geom", type="xyz", dim=f"{vis_options.body_xyz_dim}")
        else:
            # Get the parent body
            parent_body = body_elements[str(parent_idx)]

            # Add the current body
            body_pos = " ".join(map(str, positions[idx][0]))
            body = SubElement(
                parent_body, "body", name=body_name, joint="spherical", pos=body_pos
            )
            if vis_options.show_body_xyz:
                SubElement(body, "geom", type="xyz", dim=f"{vis_options.body_xyz_dim}")

        if (not skip_0th_body_imu) or parent_idx != -1:
            # Add the imu body
            imu_pos = " ".join(map(str, positions[idx][1]))
            imu_body = SubElement(
                body, "body", name=f"imu{idx}", joint="frozen", pos=imu_pos
            )
            imu_offset = " ".join(map(str, vis_options.imu_offset))
            if vis_options.show_imu_xyz:
                SubElement(
                    imu_body,
                    "geom",
                    type="xyz",
                    dim=f"{vis_options.imu_xyz_dim}",
                    # TODO: `xyz` doesn't support `pos` argument; it just gets ignored
                    # pos=imu_offset,
                )
            if vis_options.show_imu:
                SubElement(
                    imu_body,
                    "geom",
                    type=vis_options.imu_type,
                    mass="0.1",
                    dim=vis_options.imu_dim,
                    color=vis_options.imu_color,
                    pos=imu_offset,
                )

        # Store the body element for future connections
        body_elements[body_name] = body

    # Return the formatted XML string
    xml_string = tostring(root, encoding="unicode", short_empty_elements=False)

    # Print the XML string with newlines for readability
    xml_pretty = xml.dom.minidom.parseString(xml_string).toprettyxml()
    return xml_pretty


def view(
    graph: list[int | str],
    body_to_eps_rots: dict[int | str, np.ndarray],
    extras: dict[int | str, dict[str, np.ndarray]],
    hz: float,
    mode: str = "window",
    offscreen_mode_options=dict(),
    global_translation: Optional[np.ndarray] = None,
    vis_options: VisOptions = VisOptions(),
    width: Optional[int] = None,
    height: Optional[int] = None,
    show_every_nth_frame: int = 4,
    body_names: Optional[list[str]] = None,
) -> None:
    """
    Visualizes a graph-based system using MuJoCo with options for interactive or
    offscreen rendering.

    Args:
        graph (list[int]): List representing the parent-child relationships of the
            bodies in the system, where each index corresponds to a body, and the value
            is the index of its parent (-1 indicates the root body).
        body_to_eps_rots (dict[int, np.ndarray]): A dictionary mapping body indices to
            quaternion arrays representing rotations over time.
        extras (dict[int, dict[str, np.ndarray]]): A dictionary mapping body indices to
            additional parameters, such as joint-center positions.
        hz (float): The sampling frequency (frames per second).
        mode (str, optional): Rendering mode. Use "window" for interactive display or
            "offscreen" for frame capture. Defaults to "window".
        offscreen_mode_options (dict, optional): Options for offscreen rendering, such
            as `camid`, `depth`, and `output_path`. Defaults to `dict(camid=None, depth=False)`.
        global_translation (Optional[np.ndarray], optional): A (T, 3) array for global
            translation over time. Defaults to None.
        show_stars (bool, optional): Whether to display a starry background in the scene.
            Defaults to True.
        show_floor (bool, optional): Whether to display a floor in the scene. Defaults
            to True.
        show_joint_to_joint (bool, optional): Whether to show grey capsules that connect from
            jointcenter-to-jointcenter. Defaults to True.
        show_joint_to_imu (bool, optional): Wether to show lightblue capsules that connect
            from jointcenter-to-imu. Defaults to True.
        width (Optional[int], optional): Width of the rendering window in pixels. Defaults
            to None.
        height (Optional[int], optional): Height of the rendering window in pixels. Defaults
            to None.
        show_every_nth_frame (int, optional): Number of frames to show during rendering.
            Selecting `1` shows every frame while e.g. `4` shows every fourth frame.
            Defaults to 1.
        body_names (Optional[list[str]]): Names of bodies, must be provided if either
            `graph` or `body_to_eps_rots` or `extras` uses these names.
        **kwargs: Additional keyword arguments passed to the rendering scene.

    Returns:
        None
    """  # noqa: E501
    offscreen_mode_options_defaults = dict(camid=None, depth=False, github=False)
    offscreen_mode_options_defaults.update(offscreen_mode_options)
    offscreen_mode_options = offscreen_mode_options_defaults

    body_to_eps_rots = body_to_eps_rots.copy()

    graph = imt.Solver._guarantuee_body_numbers(body_names, graph)
    body_to_eps_rots = imt.Solver._guarantuee_body_numbers(body_names, body_to_eps_rots)
    extras = imt.Solver._guarantuee_body_numbers(body_names, extras)

    if mode == "offscreen":
        if "output_path" not in offscreen_mode_options:
            print(
                "To save the video permanently, provide the path to where the .mp4 is",
                " saved by specifying `offscreen_mode_options=dict(output_path=...)`",
            )
            output_path = None
        else:
            output_path = offscreen_mode_options.pop("output_path")
    gif_codec_for_github = offscreen_mode_options.pop("github")

    # these are joint-to-joint position vectors and joint-to-imu positions
    # body 0: we can skip it because we can compensate it with just the
    # `global_translation` argument
    zeros = [np.zeros((3,)), np.zeros((3,))]
    positions = {}
    for i, p in enumerate(graph):
        if p == -1:
            positions[i] = zeros
            continue

        imu_pos = extras[i]["joint-center-to-body2"]
        joint_joint_pos = -extras[i]["joint-center-to-body1"].copy()
        # if the parent was the body that connects to root then skip this
        if graph[p] != -1:
            joint_joint_pos += extras[p]["joint-center-to-body2"].copy()
        positions[i] = [joint_joint_pos, imu_pos]

    sys = ring.System.create(
        create_xml_from_graph(graph, positions, vis_options, skip_0th_body_imu=False)
    )
    geoms = ring.rendering.base_render._replace_xyz_geoms(sys.geoms)
    geoms = [ring.rendering.base_render._color_to_rgba(g) for g in geoms]
    scene = MujocoScene(
        show_stars=vis_options.show_stars,
        show_floor=vis_options.show_floor,
        floor_z=0.0,
        floor_material=vis_options.floor_material,
    )
    scene.init(geoms)
    xml_string = _mujoco_model_to_string(scene._model)

    # this dict maps bodynames to mujoco bodynames
    mujoco_bodyname = {n: str(i) for i, n in enumerate(sys.link_names)}

    if vis_options.show_joint_to_joint:
        fromto = {str(i): [] for i in range(len(sys.link_names))}
        for i, p in enumerate(graph):
            if p == -1:
                continue
            fromto[mujoco_bodyname[str(p)]].append(
                np.concatenate((np.zeros((3,)), positions[i][0]))
            )
        # now add fromto capsules to visualize segments
        xml_string = _add_capsule_geoms_to_xml(
            xml_string, fromto, 0.01, color=np.array(vis_options.joint_to_joint_color)
        )

    if vis_options.show_joint_to_imu:
        fromto = {str(i): [] for i in range(len(sys.link_names))}
        for i, p in enumerate(graph):
            if p == -1:
                continue
            fromto[mujoco_bodyname[str(i)]].append(
                np.concatenate((np.zeros((3,)), positions[i][1]))
            )
        # now add fromto capsules to visualize joint to imus
        xml_string = _add_capsule_geoms_to_xml(
            xml_string, fromto, 0.007, color=np.array(vis_options.joint_to_imu_color)
        )

    body_to_eps_rots[-1] = np.array([1.0, 0, 0, 0])
    parent_to_child_rots = [
        qmt.qmult(qmt.qinv(body_to_eps_rots[i]), body_to_eps_rots[p])
        for i, p in enumerate(graph)
    ]
    T = body_to_eps_rots[0].shape[0]
    if global_translation is None:
        global_translation = np.zeros((T, 3))
    q = np.concatenate(
        parent_to_child_rots[:1] + [global_translation] + parent_to_child_rots[1:],
        axis=-1,
    )
    x = jax.vmap(lambda q: ring.algorithms.forward_kinematics_transforms(sys, q)[0])(q)

    scene._model = mujoco.MjModel.from_xml_string(xml_string)
    scene._data = mujoco.MjData(scene._model)

    # create the viewer object
    viewer = mujoco_viewer.MujocoViewer(
        scene._model, scene._data, mode=mode, width=width, height=height
    )

    # targeted fps for onscreen rendering
    fps = hz / show_every_nth_frame
    dt_target = 1 / fps

    # simulate and render
    if mode == "window":
        t = -1
        dt = dt_target
        last_t = time.time()
        for _ in range(100_000):
            t = (t + 1) % T
            if viewer.is_alive:
                if (t % show_every_nth_frame) == 0:
                    # if enough time has passed to achieve framerate
                    while dt < dt_target:
                        time.sleep(0.001)
                        dt = time.time() - last_t

                    last_t = time.time()
                    scene.update(x[t])
                    viewer.render()
                    dt = time.time() - last_t
            else:
                break
    else:  # offscreen mode
        frames = []
        for t in range(0, T, show_every_nth_frame):
            scene.update(x[t])
            frames.append(viewer.read_pixels(**offscreen_mode_options))

    # close
    viewer.close()

    if mode == "window":
        return
    else:
        options = {}
        if gif_codec_for_github:
            options.update(dict(codec="gif"))
        if output_path is None:
            mediapy.show_video(frames, fps=fps, height=height, **options)
        else:
            mediapy.write_video(output_path, frames, fps=fps, **options)
